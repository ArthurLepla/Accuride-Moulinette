interface HierarchyLevel {
  name: string;
  level: number;
}

export interface MendixEntitySummary {
  totalEntities: {
    [key: string]: number;
  };
  [key: string]: any;
}

interface RequiredEntity {
  name: string;
  attributes: Array<{
    name: string;
    type: string;
  }>;
}

export interface IIHData {
  sectors: {
    [key: string]: {
      name: string;
      assetId: string;
      machines?: {
        [key: string]: {
          name: string;
          assetId: string;
          energyType?: string;
          variable?: {
            id: string;
            name: string;
            aggregations?: {
              [key: string]: {
                id: string;
                cycle: {
                  base: string;
                  factor: number;
                };
              };
            };
          };
          stateVariable?: {
            variableId: string;
          };
        };
      };
      workshops?: {
        [key: string]: {
          name: string;
          assetId: string;
          machines?: {
            [key: string]: {
              name: string;
              assetId: string;
              energyType?: string;
              variable?: {
                id: string;
                name: string;
                aggregations?: {
                  [key: string]: {
                    id: string;
                    cycle: {
                      base: string;
                      factor: number;
                    };
                  };
                };
              };
              stateVariable?: {
                variableId: string;
              };
            };
          };
        };
      };
    };
  };
  rootMachines: {
    [key: string]: {
      name: string;
      assetId: string;
      energyType?: string;
      variable?: {
        id: string;
        name: string;
        aggregations?: {
          [key: string]: {
            id: string;
            cycle: {
              base: string;
              factor: number;
            };
          };
        };
      };
      stateVariable?: {
        variableId: string;
      };
    };
  };
}

export function generateDynamicMendixCode(
  hierarchyLevels: HierarchyLevel[],
  mendixSummary: MendixEntitySummary
): string {
  // Fonction utilitaire pour mettre la première lettre en majuscule
  const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
  
  // Générer les noms d'entités dynamiquement
  const allEntityNames = new Set<string>();
  hierarchyLevels.forEach(level => allEntityNames.add(`Smart.${capitalize(level.name)}`)); // Corrected: Always capitalize
  hierarchyLevels.forEach(level => {
    const levelName = capitalize(level.name).replace(/\s+/g, ''); // Corrected: Always capitalize and replace spaces
    allEntityNames.add(`Smart.Aggregation_Conso_${levelName}`);
    allEntityNames.add(`Smart.Aggregation_Production_quantite_${levelName}`); // Corrected: lowercase 'quantite'
    allEntityNames.add(`Smart.Aggregation_Production_kg_${levelName}`); // Corrected: lowercase 'kg'
    allEntityNames.add(`Smart.Aggregation_IPE_quantite_${levelName}`); // Corrected: lowercase 'quantite'
    allEntityNames.add(`Smart.Aggregation_IPE_kg_${levelName}`); // Corrected: lowercase 'kg'
  });
  allEntityNames.add('Smart.EtatCapteur');

  // Create ENTITIES map for use within the generated code (optional, but can be helpful)
  const entityDefinitions = Array.from(allEntityNames).map(fullName => {
      // Generate a readable constant name, trying to match the old pattern but respecting new casing
      const shortName = fullName.replace('Smart.', '').toUpperCase()
          .replace(/_QUANTITE/g, '_QTE') // Keep this replacement for short name
          .replace(/_KG/g, '_KG') // Keep this replacement for short name
          .replace(/PRODUCTION/g, 'PROD')
          .replace(/AGGREGATION/g, 'AGG');
      return `    ${shortName}: "${fullName}",`;
  }).join('\n');

  const code = [
    '// This file was generated by Mendix Studio Pro.',
    '//',
    '// WARNING: Only the following code will be retained when actions are regenerated:',
    '// - the import list',
    '// - the code between BEGIN USER CODE and END USER CODE',
    '// - the code between BEGIN EXTRA CODE and END EXTRA CODE',
    '// Other code you write will be lost the next time you deploy the project.',
    'import "mx-global";',
    'import { Big } from "big.js";',
    '',
    '// BEGIN EXTRA CODE',
    '// Définition du mapping des entités Mendix (pour référence si besoin)',
    'const ENTITIES_MAP = {',
    entityDefinitions, // Optional: include the map if useful for debugging inside Mendix
    '};',
    '',
    '// Données pré-traitées à créer',
    'const MENDIX_SUMMARY = ' + JSON.stringify(mendixSummary, null, 2) + ';',
    '// END EXTRA CODE',
    '',
    '/**',
    ' * @returns {Promise.<void>}',
    ' */',
    'export async function JavaScript_action() {',
    '    // BEGIN USER CODE',
    '    try {',
    '        console.log("[DEBUG] Checking MENDIX_SUMMARY availability...");',
    '        if (!MENDIX_SUMMARY) {',
    '            throw new Error("MENDIX_SUMMARY is not defined or empty in the generated code.");',
    '        }',
    '        console.log("[DEBUG] MENDIX_SUMMARY is defined. Starting entity creation...");',
    '',
    '        const actualCreatedCounts = {}; // Initialize actual counts object',
    '',
    '        const createAndCommitObject = async (entityFullName, attributes) => {',
    '            return new Promise((resolve, reject) => {',
    '                try {',
    '                    // Log attempt',
    '                    const objectIdentifier = attributes.Nom || attributes.AssetName || attributes.NomCapteur || "N/A";',
    '                    console.log(`[CREATE ATTEMPT] Entity: ${entityFullName}, Identifier: ${objectIdentifier}`);',
    '                    // console.log("[DEBUG] Attributes:", JSON.stringify(attributes)); // Verbose: uncomment if needed',
    '                    ',
    '                    mx.data.create({',
    '                        entity: entityFullName, // Use the full name passed',
    '                        callback: function(obj) {',
    '                            try {',
    '                                // console.log("[CREATE] Mendix object created for", entityFullName);',
    '                                Object.entries(attributes).forEach(([key, value]) => {',
    '                                    if (value !== undefined && value !== null && key !== "entity") { // Ensure value is not null/undefined and key is not "entity"',
    '                                        // console.log(`[ATTRIBUTE] Setting ${key} = ${value} (type: ${typeof value})`); // Verbose',
    '                                        try {',
    '                                           if (typeof value === \'boolean\') {',
    '                                               obj.set(key, value);',
    '                                           } else if (typeof value === \'number\') {',
    '                                                // Handle potential large numbers or decimals if necessary',
    '                                                obj.set(key, new Big(value)); ',
    '                                           } else {',
    '                                               obj.set(key, value.toString());',
    '                                           }',
    '                                        } catch (setErr) {',
    '                                           console.warn(`[WARN] Failed to set attribute \'${key}\' for entity ${entityFullName}. Value: ${value}. Error: ${setErr.message}`);',
    '                                        }',
    '                                    }',
    '                                });',
    '                                // console.log("[COMMIT] Attempting commit for", entityFullName);',
    '                                mx.data.commit({',
    '                                    mxobj: obj,',
    '                                    callback: function() {',
    '                                        console.log(`[SUCCESS] Committed: ${entityFullName} - ${objectIdentifier}`);',
    '                                        // Increment actual count for this entity type',
    '                                        actualCreatedCounts[entityFullName] = (actualCreatedCounts[entityFullName] || 0) + 1;',
    '                                        resolve(obj);',
    '                                    },',
    '                                    error: function(e) {',
    '                                        console.error(`[ERROR] Commit failed for ${entityFullName} - ${objectIdentifier}: ${e.message}`, e);',
    '                                        reject(new Error(`Commit failed for ${entityFullName}: ${e.message}`));',
    '                                    }',
    '                                });',
    '                            } catch (configErr) {',
    '                                console.error(`[ERROR] Attribute configuration failed for ${entityFullName} - ${objectIdentifier}: ${configErr.message}`, configErr);',
    '                                reject(new Error(`Attribute configuration failed for ${entityFullName}: ${configErr.message}`));',
    '                            }',
    '                        },',
    '                        error: function(e) {',
    '                            console.error(`[ERROR] Object creation failed for ${entityFullName} - ${objectIdentifier}: ${e.message}`, e);',
    '                            reject(new Error(`Object creation failed for ${entityFullName}: ${e.message}`));',
    '                        }',
    '                    });',
    '                } catch (globalErr) {',
    '                    console.error(`[ERROR] Global error during create/commit for ${entityFullName}: ${globalErr.message}`, globalErr);',
    '                    reject(globalErr);',
    '                }',
    '            });',
    '        };',
    '',
    '        // --- Main Creation Loop ---',
    '        console.log("Starting entity creation loop from MENDIX_SUMMARY...");',
    '        let createdCount = 0;',
    '        let errorCount = 0;',
    '',
    '        // Iterate over all keys in MENDIX_SUMMARY representing arrays of entities',
    '        for (const summaryKey in MENDIX_SUMMARY) {',
    '            if (summaryKey === \'totalEntities\' || !Array.isArray(MENDIX_SUMMARY[summaryKey])) {',
    '                continue; // Skip total counts and non-array properties',
    '            }',
    '',
    '            const entityArray = MENDIX_SUMMARY[summaryKey];',
    '            console.log(`Processing ${entityArray.length} items for summary key: ${summaryKey}`);',
    '',
    '            for (const item of entityArray) {',
    '                if (!item || !item.entity || !item.attributes) {',
    '                     console.warn(`[WARNING] Skipping invalid item in MENDIX_SUMMARY key \'${summaryKey}\':`, item);',
    '                     continue;',
    '                }',
    '',
    '                // Ensure entity name starts with \'Smart.\' - Handle potential variations if needed',
    '                const entityName = item.entity.startsWith(\'Smart.\') ? item.entity : `Smart.${item.entity}`;',
    '                const attributes = item.attributes;',
    '',
    '                try {',
    '                    await createAndCommitObject(entityName, attributes);',
    '                    createdCount++;',
    '                } catch (creationError) {',
    '                     errorCount++;',
    '                     // Decide if we should throw or continue',
    '                     // throw creationError; // Option 1: Stop execution on first error',
    '                     console.warn(`Continuing creation process despite error for entity \'${entityName}\'.`); // Option 2: Continue on error (defaulting to this)',
    '                }',
    '            }',
    '             console.log(`Finished processing summary key: ${summaryKey}`);',
    '        }',
    '',
    '        console.log(`--- Creation Summary ---`);',
    '        console.log(`Successfully created/committed: ${createdCount} objects.`);',
    '        console.log(`Failed attempts: ${errorCount} objects.`);',
    '        console.log(`------------------------`);',
    '        console.log(`--- Actual Created Counts ---`);',
    '        console.log(JSON.stringify(actualCreatedCounts, null, 2));',
    '        console.log(`-----------------------------`);',
    '',
    '        if (errorCount > 0) {',
    '            mx.ui.warning(`Configuration terminée avec ${errorCount} erreur(s). Vérifiez la console pour les détails.`, {});',
    '        } else {',
    '            mx.ui.info("Configuration depuis MENDIX_SUMMARY terminée avec succès!", {});',
    '        }',
    '',
    '    } catch (error) {',
    '        console.error("Erreur globale lors de la configuration depuis MENDIX_SUMMARY:", error);',
    '        mx.ui.error("Erreur lors de la configuration: " + error.message, {});',
    '        throw error; // Re-throw the error for Mendix to handle',
    '    }',
    '    // END USER CODE',
    '}'
  ].join('\n');

  return code;
}

export function generateDynamicCleanupCode(requiredEntities: RequiredEntity[], hierarchyLevels: HierarchyLevel[]): string {
  // Fonction utilitaire pour mettre la première lettre en majuscule
  const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();

  // Generate ENTITIES map dynamically based on hierarchyLevels for cleanup targetting
  const allEntitiesForCleanup = [
    // Hierarchy levels themselves
    ...hierarchyLevels.map(level => {
        const levelName = capitalize(level.name); // Corrected: Always capitalize
        const entityFullName = `Smart.${levelName}`;
        return `    ${level.name.toUpperCase().replace(/\s+/g, '_')}: "${entityFullName}",`;
    }),
    // All possible aggregation entity patterns based on levels
    ...hierarchyLevels.flatMap(level => {
        const levelName = capitalize(level.name).replace(/\s+/g, ''); // Corrected: Always capitalize and replace spaces
        const upperLevelName = level.name.toUpperCase().replace(/\s+/g, '_');
        return [
            `    AGGREGATION_CONSO_${upperLevelName}: "Smart.Aggregation_Conso_${levelName}",`, // Corrected: Use consistent dynamic name
            `    AGGREGATION_PRODUCTION_QUANTITE_${upperLevelName}: "Smart.Aggregation_Production_quantite_${levelName}",`, // Corrected: Use consistent dynamic name
            `    AGGREGATION_PRODUCTION_KG_${upperLevelName}: "Smart.Aggregation_Production_kg_${levelName}",`, // Corrected: Use consistent dynamic name
            `    AGGREGATION_IPE_QUANTITE_${upperLevelName}: "Smart.Aggregation_IPE_quantite_${levelName}",`, // Corrected: Use consistent dynamic name
            `    AGGREGATION_IPE_KG_${upperLevelName}: "Smart.Aggregation_IPE_kg_${levelName}",` // Corrected: Use consistent dynamic name
        ];
    }),
    // Include EtatCapteur separately as it's not tied to a specific level in the same way
    '    ETAT_CAPTEUR: "Smart.EtatCapteur"'
  ];

  const entityDefinitions = allEntitiesForCleanup.join('\n');

  const code = [
    '// This file was generated by Mendix Studio Pro.',
    '//',
    '// WARNING: Only the following code will be retained when actions are regenerated:',
    '// - the import list',
    '// - the code between BEGIN USER CODE and END USER CODE',
    '// - the code between BEGIN EXTRA CODE and END EXTRA CODE',
    '// Other code you write will be lost the next time you deploy the project.',
    'import "mx-global";',
    'import { Big } from "big.js";',
    '',
    '// BEGIN EXTRA CODE',
    'const ENTITIES_TO_CLEAN = {', // Renamed for clarity
    entityDefinitions,
    '};',
    '// END EXTRA CODE',
    '',
    '/**',
    ' * @returns {Promise.<void>}',
    ' */',
    'export async function JavaScript_cleanup() {',
    '    // BEGIN USER CODE',
    '    try {',
    '        console.log("=== Début du nettoyage des entités ===");',
    '',
    '        function deleteAllEntitiesOfType(entityName) {',
    '            return new Promise((resolve, reject) => {', // Added reject path
    '                console.log(`[Cleanup] Attempting to delete all objects of type: ${entityName}`);',
    '                mx.data.get({',
    '                    xpath: `//${entityName}`,',
    '                    callback: function(objects) {',
    '                        console.log(`[Cleanup] Found ${objects.length} objects of type ${entityName} to delete.`);',
    '                        if (objects.length === 0) {',
    '                            resolve();',
    '                            return;',
    '                        }',
    '                        mx.data.remove({',
    '                           guids: objects.map(obj => obj.getGuid()),',
    '                           callback: function() {',
    '                               console.log(`[Cleanup] Successfully deleted ${objects.length} objects of type ${entityName}.`);',
    '                               resolve();',
    '                           },',
    '                           error: function(e) {',
    '                               console.error(`[Cleanup ERROR] Failed to delete objects of type ${entityName}:`, e);',
    '                               reject(e); // Reject on error',
    '                           }',
    '                       });',
    '                    },',
    '                    error: function(e) {',
    '                        console.error(`[Cleanup ERROR] Failed to retrieve objects of type ${entityName}:`, e);',
    '                        // If retrieval fails, maybe the entity doesn\'t exist, consider resolving?',
    '                        // resolve(); // Option: Continue even if retrieval fails',
    '                         reject(e); // Option: Treat as failure',
    '                    }',
    '                });',
    '            });',
    '        }',
    '',
    '        const entitiesToCleanList = Object.values(ENTITIES_TO_CLEAN);',
    '        console.log("[Cleanup] Entities targeted for deletion:", entitiesToCleanList);',
    '        let cleanupErrors = 0;',
    '',
    '        // Iterate through the defined entities and delete them',
    '        // Delete in reverse order of dependency (roughly: aggregations/sensors first, then hierarchy bottom-up)',
    '        const reversedEntities = entitiesToCleanList.slice().reverse(); // Create a reversed copy',
    '',
    '        for (const entityName of reversedEntities) {',
    '             try {',
    '                 await deleteAllEntitiesOfType(entityName);',
    '             } catch (e) {',
    '                 cleanupErrors++;',
    '                 console.warn(`[Cleanup WARN] Failed to fully clean entity ${entityName}, continuing... Error: ${e.message}`);',
    '             }',
    '        }',
    '',
    '        if (cleanupErrors > 0) {',
    '             mx.ui.warning(`Nettoyage terminé avec ${cleanupErrors} erreur(s). Vérifiez la console.`, {});',
    '        } else {',
    '             mx.ui.info("Nettoyage terminé avec succès!", {});',
    '        }',
    '    } catch (error) {',
    '        console.error("Erreur globale lors du nettoyage:", error);',
    '        mx.ui.error("Erreur lors du nettoyage: " + error.message, {});',
    '        throw error; // Re-throw',
    '    }',
    '    // END USER CODE',
    '}'
  ].join('\n');

  return code;
} 
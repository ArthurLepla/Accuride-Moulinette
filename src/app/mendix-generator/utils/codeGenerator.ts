interface HierarchyLevel {
  name: string;
  level: number;
}

export interface MendixEntitySummary {
  totalEntities: {
    [key: string]: number;
  };
  [key: string]: any;
}

interface RequiredEntity {
  name: string;
  attributes: Array<{
    name: string;
    type: string;
  }>;
}

export interface IIHData {
  sectors: {
    [key: string]: {
      name: string;
      assetId: string;
      machines?: {
        [key: string]: {
          name: string;
          assetId: string;
          energyType?: string;
          variable?: {
            id: string;
            name: string;
            aggregations?: {
              [key: string]: {
                id: string;
                cycle: {
                  base: string;
                  factor: number;
                };
              };
            };
          };
          stateVariable?: {
            variableId: string;
          };
        };
      };
      workshops?: {
        [key: string]: {
          name: string;
          assetId: string;
          machines?: {
            [key: string]: {
              name: string;
              assetId: string;
              energyType?: string;
              variable?: {
                id: string;
                name: string;
                aggregations?: {
                  [key: string]: {
                    id: string;
                    cycle: {
                      base: string;
                      factor: number;
                    };
                  };
                };
              };
              stateVariable?: {
                variableId: string;
              };
            };
          };
        };
      };
    };
  };
  rootMachines: {
    [key: string]: {
      name: string;
      assetId: string;
      energyType?: string;
      variable?: {
        id: string;
        name: string;
        aggregations?: {
          [key: string]: {
            id: string;
            cycle: {
              base: string;
              factor: number;
            };
          };
        };
      };
      stateVariable?: {
        variableId: string;
      };
    };
  };
}

export function generateDynamicMendixCode(
  hierarchyLevels: HierarchyLevel[],
  requiredEntities: RequiredEntity[],
  iihData: IIHData,
  mendixSummary: MendixEntitySummary
): string {
  // Fonction utilitaire pour mettre la première lettre en majuscule
  const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
  
  // Générer les noms d'entités dynamiquement
  const allEntities = [
    // Entités de base pour les niveaux hiérarchiques
    ...hierarchyLevels.map(level => 
      `    ${level.name.toUpperCase()}: "Smart.${level.name === 'ETH' ? 'ETH' : capitalize(level.name)}",`
    ),
    // Entités d'agrégation par niveau
    ...hierarchyLevels.map(level => {
      const levelName = level.name === 'ETH' ? 'ETH' : capitalize(level.name).replace(/\s+/g, '');
      return [
        `    AGGREGATION_CONSO_${level.name.toUpperCase()}: "Smart.Aggregation_Conso_${levelName}",`,
        `    AGGREGATION_PRODUCTION_QUANTITE_${level.name.toUpperCase()}: "Smart.Aggregation_Production_quantite_${levelName}",`,
        `    AGGREGATION_PRODUCTION_KG_${level.name.toUpperCase()}: "Smart.Aggregation_Production_kg_${levelName}",`,
        `    AGGREGATION_IPE_QUANTITE_${level.name.toUpperCase()}: "Smart.Aggregation_IPE_quantite_${levelName}",`,
        `    AGGREGATION_IPE_KG_${level.name.toUpperCase()}: "Smart.Aggregation_IPE_kg_${levelName}",`
      ];
    }).flat(),
    '    ETAT_CAPTEUR: "Smart.EtatCapteur"'
  ];

  const entityDefinitions = allEntities.join('\n');

  const code = [
    '// This file was generated by Mendix Studio Pro.',
    '//',
    '// WARNING: Only the following code will be retained when actions are regenerated:',
    '// - the import list',
    '// - the code between BEGIN USER CODE and END USER CODE',
    '// - the code between BEGIN EXTRA CODE and END EXTRA CODE',
    '// Other code you write will be lost the next time you deploy the project.',
    'import "mx-global";',
    'import { Big } from "big.js";',
    '',
    '// BEGIN EXTRA CODE',
    'const ENTITIES = {',
    entityDefinitions,
    '};',
    '',
    '// Données des assets (structure hiérarchique complète)',
    'const ASSETS_DATA = ' + JSON.stringify(iihData, null, 2) + ';',
    '',
    '// Niveaux hiérarchiques',
    'const HIERARCHY_LEVELS = ' + JSON.stringify(hierarchyLevels, null, 2) + ';',
    '',
    '// Définition du mapping des entités Mendix',
    'const MENDIX_SUMMARY = ' + JSON.stringify(mendixSummary, null, 2) + ';',
    '// END EXTRA CODE',
    '',
    '/**',
    ' * @returns {Promise.<void>}',
    ' */',
    'export async function JavaScript_action() {',
    '    // BEGIN USER CODE',
    '    try {',
    '        // Vérification des données',
    '        console.log("[DEBUG] Checking data availability...");',
    '        if (!ASSETS_DATA) {',
    '            throw new Error("ASSETS_DATA is not defined");',
    '        }',
    '        console.log("[DEBUG] ASSETS_DATA is defined");',
    '        console.log("[DEBUG] ASSETS_DATA structure:", JSON.stringify(ASSETS_DATA, null, 2));',
    '',
    '        if (!MENDIX_SUMMARY) {',
    '            throw new Error("MENDIX_SUMMARY is not defined");',
    '        }',
    '        console.log("[DEBUG] MENDIX_SUMMARY is defined");',
    '        console.log("[DEBUG] MENDIX_SUMMARY structure:", JSON.stringify(MENDIX_SUMMARY, null, 2));',
    '',
    '        const createAndCommitObject = async (entity, attributes) => {',
    '            return new Promise((resolve, reject) => {',
    '                try {',
    '                    console.log("[CREATE] Starting entity creation: " + entity);',
    '                    console.log("[CREATE] Attributes: " + JSON.stringify(attributes));',
    '                    mx.data.create({',
    '                        entity: entity,',
    '                        callback: function(obj) {',
    '                            try {',
    '                                console.log("[CREATE] Entity created successfully");',
    '                                Object.entries(attributes).forEach(([key, value]) => {',
    '                                    if (value !== undefined && value !== null) {',
    '                                        console.log(`[ATTRIBUTE] Setting ${key} = ${value} (type: ${typeof value})`);',
    '                                        if (typeof value === \'boolean\') {',
    '                                            obj.set(key, value);',
    '                                        } else {',
    '                                            obj.set(key, value.toString());',
    '                                        }',
    '                                    }',
    '                                });',
    '                                console.log("[COMMIT] Attempting to commit");',
    '                                mx.data.commit({',
    '                                    mxobj: obj,',
    '                                    callback: function() {',
    '                                        console.log("[SUCCESS] Entity committed: " + entity);',
    '                                        resolve(obj);',
    '                                    },',
    '                                    error: function(e) {',
    '                                        console.error("[ERROR] Commit failed: " + e.message);',
    '                                        reject(new Error("Commit failed: " + e.message));',
    '                                    }',
    '                                });',
    '                            } catch (err) {',
    '                                console.error("[ERROR] Configuration failed: " + err.message);',
    '                                reject(new Error("Configuration failed: " + err.message));',
    '                            }',
    '                        },',
    '                        error: function(e) {',
    '                            console.error("[ERROR] Creation failed: " + e.message);',
    '                            reject(new Error("Creation failed: " + e.message));',
    '                        }',
    '                    });',
    '                } catch (err) {',
    '                    console.error("[ERROR] Global error: " + err.message);',
    '                    reject(err);',
    '                }',
    '            });',
    '        };',
    '',
    '        // Traitement direct des données hiérarchiques',
    '        const nodes = ASSETS_DATA.hierarchyData.nodes;',
    '        const links = ASSETS_DATA.hierarchyData.links;',
    '        console.log("[DEBUG] Processing nodes:", JSON.stringify(nodes, null, 2));',
    '        console.log("[DEBUG] Processing links:", JSON.stringify(links, null, 2));',
    '        console.log("[DEBUG] Hierarchy levels:", JSON.stringify(HIERARCHY_LEVELS, null, 2));',
    '',
    '        // Fonction pour trouver tous les parents d\'un noeud',
    '        const findAllParents = (nodeId) => {',
    '            const parents = [];',
    '            let currentNodeId = nodeId;',
    '',
    '            while (true) {',
    '                const parentLink = links.find(link => link.target === currentNodeId);',
    '                if (!parentLink) break;',
    '',
    '                const parentNode = nodes.find(node => node.id === parentLink.source);',
    '                if (!parentNode) break;',
    '',
    '                console.log("[DEBUG] Parent trouve pour " + nodeId + ":", {',
    '                    level: parentNode.metadata.level,',
    '                    name: parentNode.name',
    '                });',
    '',
    '                parents.push(parentNode);',
    '                currentNodeId = parentNode.id;',
    '            }',
    '',
    '            return parents;',
    '        };',
    '',
    '        // Déterminer le niveau maximum réel',
    '        let maxLevel = 0;',
    '        if (HIERARCHY_LEVELS && HIERARCHY_LEVELS.length > 0) {',
    '            maxLevel = Math.max(...HIERARCHY_LEVELS.map(l => l.level));',
    '        }',
    '        console.log("[DEBUG] Max hierarchy level determined:", maxLevel);',
    '',
    '        // Creer les objets pour chaque niveau hierarchique',
    '        for (const level of HIERARCHY_LEVELS) {',
    '            const levelNodes = nodes.filter(node => node.metadata.level === level.name);',
    '            console.log("[DEBUG] Found " + level.name + ":", JSON.stringify(levelNodes, null, 2));',
    '',
    '            for (const node of levelNodes) {',
    '                console.log("[" + level.name.toUpperCase() + "] Creating " + level.name + ":", node.name);',
    '                const attributes = {',
    '                    "Nom": node.name,',
    '                    "TotalConso": "0"',
    '                };',
    '',
    '                // Pour tous les niveaux sauf le premier, chercher les parents',
    '                if (level.level > 0) {',
    '                    const parents = findAllParents(node.id);',
    '                    console.log("[DEBUG] Parents trouves pour " + node.name + ":", ',
    '                        parents.map(p => ({ level: p.metadata.level, name: p.name })));',
    '',
    '                    // Ajouter chaque parent comme attribut',
    '                    parents.forEach(parent => {',
    '                        const parentLevelName = parent.metadata.level;',
    '                        attributes[parentLevelName] = parent.name;',
    '                        console.log("[DEBUG] Ajout de attribut " + parentLevelName + "=" + parent.name);',
    '                    });',
    '                }',
    '',
    '                // *** AJOUT : Ajouter les indicateurs isElec, isGaz, etc. pour les niveaux SAUF le dernier ***',
    '                // Vérifier si ce n\'est PAS le dernier niveau réel',
    '                const isActuallyLastLevel = level.level === maxLevel; // Utiliser le maxLevel calculé',
    '                if (!isActuallyLastLevel) { // Ne pas ajouter pour le dernier niveau',
    '                    console.log(`[ATTRIBUTES] Ajout des flags isElec/Gaz/Eau/Air pour ${node.name} (niveau ${level.name})`);',
    '                    // Ajouter les flags booléens depuis les métadonnées, en s\'assurant qu\'ils existent',
    '                    attributes["isElec"] = node.metadata.isElec === true;',
    '                    attributes["isGaz"] = node.metadata.isGaz === true;',
    '                    attributes["isEau"] = node.metadata.isEau === true;',
    '                    attributes["isAir"] = node.metadata.isAir === true;',
    '                }',
    '',
    '                // Ajouter les attributs specifiques pour les machines',
    '                if (level.name === "Machine") {',
    '                    attributes["Identifiant"] = node.metadata.assetId || node.id;',
    '                    attributes["IPE"] = "0";',
    '                    attributes["TypeEnergie"] = node.metadata.energyType || node.metadata.rawEnergyType || "";',
    '',
    '                    // Trouver le secteur parent (directement ou via l\'atelier)',
    '                    const parentSecteur = findAllParents(node.id).find(p => p.metadata.level === "Secteur");',
    '                    if (parentSecteur) {',
    '                        console.log(`[DEBUG] Secteur parent trouve pour ${node.name}:`, parentSecteur.name);',
    '                        attributes["Secteur"] = parentSecteur.name;',
    '                    }',
    '',
    '                    // Trouver l\'atelier parent',
    '                    const parentAtelier = findAllParents(node.id).find(p => p.metadata.level === "Atelier");',
    '                    if (parentAtelier) {',
    '                        console.log(`[DEBUG] Atelier parent trouve pour ${node.name}:`, parentAtelier.name);',
    '                        attributes["Atelier"] = parentAtelier.name;',
    '                    }',
    '                }',
    '',
    '                // Creer l\'objet',
    '                await createAndCommitObject(',
    '                    ENTITIES[level.name.toUpperCase()],',
    '                    attributes',
    '                );',
    '',
    '                // Traiter les variables et créer les entités d\'agrégation appropriées',
    '                await createAggregationEntities(node, level, findAllParents);',
    '            }',
    '        }',
    '',
    '        // Fonction pour créer les entités d\'agrégation pour un nœud',
    '        async function createAggregationEntities(node, level, findParents) {',
    '            const levelName = level.name;',
    '            const isLastLevel = level.level === HIERARCHY_LEVELS.length - 1; // Niveau Machine',
    '            const parents = findParents(node.id);',
    '            const parentSector = parents.find(p => p.metadata.level === "Secteur");',
    '            const parentWorkshop = parents.find(p => p.metadata.level === "Atelier");',
    '',
    '            // 1. Créer les entités d\'agrégation pour la consommation',
    '            if (isLastLevel && node.metadata.variable) {',
    '                // Code existant pour les machines de niveau 5',
    '                console.log(`[VARIABLE] Creating consumption variable for ${levelName}:`, node.name);',
    '                const aggConsoAttributes = {',
    '                    "VariableId": node.metadata.variable.variableId,',
    '                    "VariableName": node.metadata.variable.name,',
    '                    "AssetName": node.name,',
    '                    [levelName]: node.name,',
    '                    "TypeEnergie": node.metadata.energyType || node.metadata.rawEnergyType || "Elec"',
    '                };',
    '',
    '                // Ajouter les références aux parents',
    '                if (parentSector) aggConsoAttributes["Secteur"] = parentSector.name;',
    '                if (parentWorkshop) aggConsoAttributes["Atelier"] = parentWorkshop.name;',
    '',
    '                // Ajouter les IDs des agrégations',
    '                if (node.metadata.variable.aggregations) {',
    '                    const aggs = node.metadata.variable.aggregations;',
    '                    if (aggs["5min"]) aggConsoAttributes["Identifiant5Min"] = aggs["5min"].id;',
    '                    if (aggs["1h"]) aggConsoAttributes["Identifiant1h"] = aggs["1h"].id;',
    '                    if (aggs["4h"]) aggConsoAttributes["Identifiant4h"] = aggs["4h"].id;',
    '                    if (aggs["8h"]) aggConsoAttributes["Identifiant8h"] = aggs["8h"].id;',
    '                    if (aggs["1d"]) aggConsoAttributes["Identifiant1day"] = aggs["1d"].id;',
    '                }',
    '',
    '                // Créer l\'entité d\'agrégation',
    '                await createAndCommitObject(',
    '                    ENTITIES[`AGGREGATION_CONSO_${levelName.toUpperCase()}`],',
    '                    aggConsoAttributes',
    '                );',
    '            } else if (!isLastLevel) {',
    '                // NOUVEAU: Traiter les variables par type d\'energie pour niveaux 1-4',
    '                const energyTypes = [',
    '                    { type: \'Elec\', varField: \'elecVariable\', flag: \'isElec\' },',
    '                    { type: \'Gaz\', varField: \'gazVariable\', flag: \'isGaz\' },',
    '                    { type: \'Eau\', varField: \'eauVariable\', flag: \'isEau\' },',
    '                    { type: \'Air\', varField: \'airVariable\', flag: \'isAir\' }',
    '                ];',
    '',
    '                for (const { type, varField, flag } of energyTypes) {',
    '                    if (node.metadata[flag] && node.metadata[varField]) {',
    '                        const energyVar = node.metadata[varField];',
    '                        console.log(`[VARIABLE] Creating ${type} consumption for ${levelName}:`, node.name);',
    '',
    '                        const aggConsoAttributes = {',
    '                            "VariableId": energyVar.variableId,',
    '                            "VariableName": energyVar.variableName,',
    '                            "AssetName": node.name,',
    '                            [levelName]: node.name,',
    '                            "TypeEnergie": type',
    '                        };',
    '',
    '                        // Ajouter les références aux parents',
    '                        if (parentSector) aggConsoAttributes["Secteur"] = parentSector.name;',
    '                        if (parentWorkshop) aggConsoAttributes["Atelier"] = parentWorkshop.name;',
    '',
    '                        // Ajouter les IDs des agrégations',
    '                        if (energyVar.aggregations) {',
    '                            const aggs = energyVar.aggregations;',
    '                            if (aggs["5min"]) aggConsoAttributes["Identifiant5Min"] = aggs["5min"].id;',
    '                            if (aggs["1h"]) aggConsoAttributes["Identifiant1h"] = aggs["1h"].id;',
    '                            if (aggs["4h"]) aggConsoAttributes["Identifiant4h"] = aggs["4h"].id;',
    '                            if (aggs["8h"]) aggConsoAttributes["Identifiant8h"] = aggs["8h"].id;',
    '                            if (aggs["1d"]) aggConsoAttributes["Identifiant1day"] = aggs["1d"].id;',
    '                        }',
    '',
    '                        // Créer l\'entité d\'agrégation',
    '                        await createAndCommitObject(',
    '                            ENTITIES[`AGGREGATION_CONSO_${levelName.toUpperCase()}`],',
    '                            aggConsoAttributes',
    '                        );',
    '                    }',
    '                }',
    '            }',
    '',
    '            // 2. Créer l\'entité d\'agrégation pour la production (quantité)',
    '            if (node.metadata.productionVariable) {',
    '                console.log(`[VARIABLE] Creating production quantity variable for ${levelName}:`, node.name);',
    '                const aggProdQteAttributes = {',
    '                    "VariableId": node.metadata.productionVariable.id,',
    '                    "VariableName": node.metadata.productionVariable.name,',
    '                    "AssetName": node.name,',
    '                    [levelName]: node.name',
    '                };',
    '',
    '                // Ajouter les références aux parents si disponibles',
    '                if (parentSector) aggProdQteAttributes["Secteur"] = parentSector.name;',
    '                if (parentWorkshop) aggProdQteAttributes["Atelier"] = parentWorkshop.name;',
    '',
    '                // Ajouter les IDs des agrégations',
    '                if (node.metadata.productionVariable.aggregations) {',
    '                    const aggs = node.metadata.productionVariable.aggregations;',
    '                    if (aggs["5min"]) aggProdQteAttributes["Identifiant5Min"] = aggs["5min"].id;',
    '                    if (aggs["1h"]) aggProdQteAttributes["Identifiant1h"] = aggs["1h"].id;',
    '                    if (aggs["4h"]) aggProdQteAttributes["Identifiant4h"] = aggs["4h"].id;',
    '                    if (aggs["8h"]) aggProdQteAttributes["Identifiant8h"] = aggs["8h"].id;',
    '                    if (aggs["1d"]) aggProdQteAttributes["Identifiant1day"] = aggs["1d"].id;',
    '                }',
    '',
    '                // Créer l\'entité d\'agrégation de production quantité pour ce niveau',
    '                await createAndCommitObject(',
    '                    ENTITIES[`AGGREGATION_PRODUCTION_QUANTITE_${levelName.toUpperCase()}`],',
    '                    aggProdQteAttributes',
    '                );',
    '            }',
    '',
    '            // 3. Créer l\'entité d\'agrégation pour la production (kg)',
    '            if (node.metadata.productionKgVariable) {',
    '                console.log(`[VARIABLE] Creating production kg variable for ${levelName}:`, node.name);',
    '                const aggProdKgAttributes = {',
    '                    "VariableId": node.metadata.productionKgVariable.id,',
    '                    "VariableName": node.metadata.productionKgVariable.name,',
    '                    "AssetName": node.name,',
    '                    [levelName]: node.name',
    '                };',
    '',
    '                // Ajouter les références aux parents si disponibles',
    '                if (parentSector) aggProdKgAttributes["Secteur"] = parentSector.name;',
    '                if (parentWorkshop) aggProdKgAttributes["Atelier"] = parentWorkshop.name;',
    '',
    '                // Ajouter les IDs des agrégations',
    '                if (node.metadata.productionKgVariable.aggregations) {',
    '                    const aggs = node.metadata.productionKgVariable.aggregations;',
    '                    if (aggs["5min"]) aggProdKgAttributes["Identifiant5Min"] = aggs["5min"].id;',
    '                    if (aggs["1h"]) aggProdKgAttributes["Identifiant1h"] = aggs["1h"].id;',
    '                    if (aggs["4h"]) aggProdKgAttributes["Identifiant4h"] = aggs["4h"].id;',
    '                    if (aggs["8h"]) aggProdKgAttributes["Identifiant8h"] = aggs["8h"].id;',
    '                    if (aggs["1d"]) aggProdKgAttributes["Identifiant1day"] = aggs["1d"].id;',
    '                }',
    '',
    '                // Créer l\'entité d\'agrégation de production kg pour ce niveau',
    '                await createAndCommitObject(',
    '                    ENTITIES[`AGGREGATION_PRODUCTION_KG_${levelName.toUpperCase()}`],',
    '                    aggProdKgAttributes',
    '                );',
    '            }',
    '',
    '            // 4. Créer l\'entité d\'agrégation pour l\'IPE (quantité)',
    '            if (node.metadata.ipeVariable || node.metadata.ipeQuantiteVariable) {',
    '                const ipeVar = node.metadata.ipeVariable || node.metadata.ipeQuantiteVariable;',
    '                console.log(`[VARIABLE] Creating IPE quantity variable for ${levelName}:`, node.name);',
    '                const aggIPEQteAttributes = {',
    '                    "VariableId": ipeVar.id,',
    '                    "VariableName": ipeVar.name,',
    '                    "AssetName": node.name,',
    '                    [levelName]: node.name,',
    '                    "TypeEnergie": node.metadata.energyType || node.metadata.rawEnergyType || "Elec"',
    '                };',
    '',
    '                // Ajouter les références aux parents si disponibles',
    '                if (parentSector) aggIPEQteAttributes["Secteur"] = parentSector.name;',
    '                if (parentWorkshop) aggIPEQteAttributes["Atelier"] = parentWorkshop.name;',
    '',
    '                // Ajouter les IDs des agrégations',
    '                if (ipeVar.aggregations) {',
    '                    const aggs = ipeVar.aggregations;',
    '                    if (aggs["5min"]) aggIPEQteAttributes["Identifiant5Min"] = aggs["5min"].id;',
    '                    if (aggs["1h"]) aggIPEQteAttributes["Identifiant1h"] = aggs["1h"].id;',
    '                    if (aggs["4h"]) aggIPEQteAttributes["Identifiant4h"] = aggs["4h"].id;',
    '                    if (aggs["8h"]) aggIPEQteAttributes["Identifiant8h"] = aggs["8h"].id;',
    '                    if (aggs["1d"]) aggIPEQteAttributes["Identifiant1day"] = aggs["1d"].id;',
    '                }',
    '',
    '                // Créer l\'entité d\'agrégation d\'IPE quantité pour ce niveau',
    '                await createAndCommitObject(',
    '                    ENTITIES[`AGGREGATION_IPE_QUANTITE_${levelName.toUpperCase()}`],',
    '                    aggIPEQteAttributes',
    '                );',
    '            }',
    '',
    '            // 5. Créer l\'entité d\'agrégation pour l\'IPE (kg)',
    '            if (node.metadata.ipeKgVariable) {',
    '                console.log(`[VARIABLE] Creating IPE kg variable for ${levelName}:`, node.name);',
    '                const aggIPEKgAttributes = {',
    '                    "VariableId": node.metadata.ipeKgVariable.id,',
    '                    "VariableName": node.metadata.ipeKgVariable.name,',
    '                    "AssetName": node.name,',
    '                    [levelName]: node.name,',
    '                    "TypeEnergie": node.metadata.energyType || node.metadata.rawEnergyType || "Elec"',
    '                };',
    '',
    '                // Ajouter les références aux parents si disponibles',
    '                if (parentSector) aggIPEKgAttributes["Secteur"] = parentSector.name;',
    '                if (parentWorkshop) aggIPEKgAttributes["Atelier"] = parentWorkshop.name;',
    '',
    '                // Ajouter les IDs des agrégations',
    '                if (node.metadata.ipeKgVariable.aggregations) {',
    '                    const aggs = node.metadata.ipeKgVariable.aggregations;',
    '                    if (aggs["5min"]) aggIPEKgAttributes["Identifiant5Min"] = aggs["5min"].id;',
    '                    if (aggs["1h"]) aggIPEKgAttributes["Identifiant1h"] = aggs["1h"].id;',
    '                    if (aggs["4h"]) aggIPEKgAttributes["Identifiant4h"] = aggs["4h"].id;',
    '                    if (aggs["8h"]) aggIPEKgAttributes["Identifiant8h"] = aggs["8h"].id;',
    '                    if (aggs["1d"]) aggIPEKgAttributes["Identifiant1day"] = aggs["1d"].id;',
    '                }',
    '',
    '                // Créer l\'entité d\'agrégation d\'IPE kg pour ce niveau',
    '                await createAndCommitObject(',
    '                    ENTITIES[`AGGREGATION_IPE_KG_${levelName.toUpperCase()}`],',
    '                    aggIPEKgAttributes',
    '                );',
    '            }',
    '',
    '            // 6. Traiter les états des capteurs (uniquement pour les machines)',
    '            if (levelName === "Machine" && node.metadata.stateVariable) {',
    '                console.log("[SENSOR] Creating sensor state for:", node.name);',
    '                await createAndCommitObject(',
    '                    ENTITIES.ETAT_CAPTEUR,',
    '                    {',
    '                        "NomCapteur": node.name,',
    '                        "Etat": "false",',
    '                        "DerniereMaj": new Date().toISOString(),',
    '                        "IdEtatCapteur": node.metadata.stateVariable.variableId',
    '                    }',
    '                );',
    '            }',
    '        }',
    '',
    '        mx.ui.info("Configuration terminée avec succès!", {});',
    '    } catch (error) {',
    '        console.error("Erreur lors de la configuration:", error);',
    '        mx.ui.error("Erreur lors de la configuration: " + error.message, {});',
    '        throw error;',
    '    }',
    '    // END USER CODE',
    '}'
  ].join('\n');

  return code;
}

export function generateDynamicCleanupCode(requiredEntities: RequiredEntity[], hierarchyLevels: HierarchyLevel[]): string {
  // Fonction utilitaire pour mettre la première lettre en majuscule
  const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();

  const allEntities = [
    ...hierarchyLevels.map(level => 
      `    ${level.name.toUpperCase()}: "Smart.${level.name === 'ETH' ? 'ETH' : capitalize(level.name)}",`
    ),
    // Agrégations de consommation pour chaque niveau
    ...hierarchyLevels.map(level => 
      `    AGGREGATION_CONSO_${level.name.toUpperCase()}: "Smart.Aggregation_Conso_${level.name === 'ETH' ? 'ETH' : capitalize(level.name)}",`
    ),
    // Agrégations de production (quantité) pour chaque niveau sauf le dernier
    ...hierarchyLevels.slice(0, -1).map(level => 
      `    AGGREGATION_PRODUCTION_QUANTITE_${level.name.toUpperCase()}: "Smart.Aggregation_Production_quantite_${level.name === 'ETH' ? 'ETH' : capitalize(level.name)}",`
    ),
    // Agrégations de production (kg) pour chaque niveau sauf le dernier
    ...hierarchyLevels.slice(0, -1).map(level => 
      `    AGGREGATION_PRODUCTION_KG_${level.name.toUpperCase()}: "Smart.Aggregation_Production_kg_${level.name === 'ETH' ? 'ETH' : capitalize(level.name)}",`
    ),
    // Agrégations d'IPE (quantité) pour chaque niveau sauf le dernier
    ...hierarchyLevels.slice(0, -1).map(level => 
      `    AGGREGATION_IPE_QUANTITE_${level.name.toUpperCase()}: "Smart.Aggregation_IPE_quantite_${level.name === 'ETH' ? 'ETH' : capitalize(level.name)}",`
    ),
    // Agrégations d'IPE (kg) pour chaque niveau sauf le dernier
    ...hierarchyLevels.slice(0, -1).map(level => 
      `    AGGREGATION_IPE_KG_${level.name.toUpperCase()}: "Smart.Aggregation_IPE_kg_${level.name === 'ETH' ? 'ETH' : capitalize(level.name)}",`
    ),
    '    ETAT_CAPTEUR: "Smart.EtatCapteur"'
  ];

  const entityDefinitions = allEntities.join('\n');

  const code = [
    '// This file was generated by Mendix Studio Pro.',
    '//',
    '// WARNING: Only the following code will be retained when actions are regenerated:',
    '// - the import list',
    '// - the code between BEGIN USER CODE and END USER CODE',
    '// - the code between BEGIN EXTRA CODE and END EXTRA CODE',
    '// Other code you write will be lost the next time you deploy the project.',
    'import "mx-global";',
    'import { Big } from "big.js";',
    '',
    '// BEGIN EXTRA CODE',
    'const ENTITIES = {',
    entityDefinitions,
    '};',
    '',
    '// Niveaux hiérarchiques',
    'const HIERARCHY_LEVELS = ' + JSON.stringify(hierarchyLevels, null, 2) + ';',
    '// END EXTRA CODE',
    '',
    '/**',
    ' * @returns {Promise.<void>}',
    ' */',
    'export async function JavaScript_cleanup() {',
    '    // BEGIN USER CODE',
    '    try {',
    '        console.log("=== Début du nettoyage des entités ===");',
    '',
    '        // Fonction utilitaire pour mettre la première lettre en majuscule',
    '        function capitalize(str) {',
    '            return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();',
    '        }',
    '',
    '        function deleteAllEntitiesOfType(entityName) {',
    '            return new Promise((resolve) => {',
    '                try {',
    '                    mx.data.get({',
    '                        xpath: `//${entityName}`,',
    '                        callback: function(objects) {',
    '                            console.log(`Suppression de ${objects.length} objets de type ${entityName}`);',
    '                            ',
    '                            if (objects.length === 0) {',
    '                                resolve();',
    '                                return;',
    '                            }',
    '                            ',
    '                            let deleteCount = 0;',
    '                            objects.forEach(function(obj) {',
    '                                mx.data.remove({',
    '                                    guid: obj.getGuid(),',
    '                                    callback: function() {',
    '                                        deleteCount++;',
    '                                        if (deleteCount === objects.length) {',
    '                                            console.log(`Tous les objets de type ${entityName} ont été supprimés`);',
    '                                            resolve();',
    '                                        }',
    '                                    },',
    '                                    error: function(e) {',
    '                                        console.warn(`Erreur lors de la suppression d\'un objet de type ${entityName}:`, e);',
    '                                        deleteCount++; // Continuer malgré l\'erreur',
    '                                        if (deleteCount === objects.length) {',
    '                                            resolve();',
    '                                        }',
    '                                    }',
    '                                });',
    '                            });',
    '                        },',
    '                        error: function(e) {',
    '                            console.warn(`Erreur lors de la récupération des objets de type ${entityName}:`, e);',
    '                            resolve(); // Continuer malgré l\'erreur',
    '                        }',
    '                    });',
    '                } catch (e) {',
    '                    console.warn(`Exception lors du traitement de l\'entité ${entityName}:`, e);',
    '                    resolve(); // Continuer malgré l\'erreur',
    '                }',
    '            });',
    '        }',
    '',
    '        async function attemptCleanupForEntity(entityName) {',
    '            try {',
    '                await deleteAllEntitiesOfType(entityName);',
    '            } catch (e) {',
    '                console.warn(`Échec de nettoyage pour ${entityName}, continuation...`);',
    '            }',
    '        }',
    '',
    '        // Supprimer d\'abord les états de capteurs',
    '        console.log("1. Suppression des capteurs...");',
    '        await attemptCleanupForEntity(ENTITIES.ETAT_CAPTEUR);',
    '        ',
    '        // Essayer différentes variantes de casse pour les agrégations',
    '        console.log("2. Suppression des agrégations pour tous les niveaux...");',
    '        for (const level of HIERARCHY_LEVELS.map(l => l.name)) {',
    '            // Versions possibles du nom de niveau',
    '            const levelVariants = [level, level.toUpperCase(), level.toLowerCase(), capitalize(level)];',
    '            ',
    '            // Pour chaque type d\'agrégation',
    '            for (const type of ["Conso", "Production_Quantite", "Production_quantite", "Production_Kg", "Production_kg", "IPE_Quantite", "IPE_quantite", "IPE_Kg", "IPE_kg"]) {',
    '                const typeVariants = [type, type.toUpperCase(), type.replace("_", "")];',
    '                ',
    '                // Essayer différentes combinaisons de casse pour le type et le niveau',
    '                for (const levelVariant of levelVariants) {',
    '                    for (const typeVariant of typeVariants) {',
    '                        await attemptCleanupForEntity(`Smart.Aggregation_${typeVariant}_${levelVariant}`);',
    '                    }',
    '                }',
    '            }',
    '        }',
    '        ',
    '        // Supprimer la hiérarchie du bas vers le haut',
    '        console.log("3. Suppression des entités hiérarchiques...");',
    '        for (let i = HIERARCHY_LEVELS.length - 1; i >= 0; i--) {',
    '            const level = HIERARCHY_LEVELS[i].name;',
    '            await attemptCleanupForEntity(`Smart.${level === "ETH" ? "ETH" : capitalize(level)}`);',
    '        }',
    '        ',
    '        mx.ui.info("Nettoyage terminé avec succès!", {});',
    '    } catch (error) {',
    '        console.error("Erreur lors du nettoyage:", error);',
    '        mx.ui.info("Nettoyage terminé avec des avertissements.", {}); // Moins dramatique qu\'une erreur',
    '    }',
    '    // END USER CODE',
    '}'
  ].join('\n');

  return code;
} 
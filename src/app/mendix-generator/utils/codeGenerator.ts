interface HierarchyLevel {
  name: string;
  level: number;
}

export interface MendixEntitySummary {
  totalEntities: {
    [key: string]: number;
  };
  [key: string]: any;
}

interface RequiredEntity {
  name: string;
  attributes: Array<{
    name: string;
    type: string;
  }>;
}

export interface IIHData {
  sectors: {
    [key: string]: {
      name: string;
      assetId: string;
      machines?: {
        [key: string]: {
          name: string;
          assetId: string;
          energyType?: string;
          variable?: {
            id: string;
            name: string;
            aggregations?: {
              [key: string]: {
                id: string;
                cycle: {
                  base: string;
                  factor: number;
                };
              };
            };
          };
          stateVariable?: {
            variableId: string;
          };
        };
      };
      workshops?: {
        [key: string]: {
          name: string;
          assetId: string;
          machines?: {
            [key: string]: {
              name: string;
              assetId: string;
              energyType?: string;
              variable?: {
                id: string;
                name: string;
                aggregations?: {
                  [key: string]: {
                    id: string;
                    cycle: {
                      base: string;
                      factor: number;
                    };
                  };
                };
              };
              stateVariable?: {
                variableId: string;
              };
            };
          };
        };
      };
    };
  };
  rootMachines: {
    [key: string]: {
      name: string;
      assetId: string;
      energyType?: string;
      variable?: {
        id: string;
        name: string;
        aggregations?: {
          [key: string]: {
            id: string;
            cycle: {
              base: string;
              factor: number;
            };
          };
        };
      };
      stateVariable?: {
        variableId: string;
      };
    };
  };
}

export function generateDynamicMendixCode(
  hierarchyLevels: HierarchyLevel[],
  requiredEntities: RequiredEntity[],
  iihData: IIHData,
  mendixSummary: MendixEntitySummary
): string {
  const allEntities = [
    ...hierarchyLevels.map(level => 
      `    ${level.name.toUpperCase()}: "Smart.${level.name}",`
    ),
    '    AGGREGATION_CONSO: "Smart.Aggregation_Conso",',
    '    AGGREGATION_PRODUCTION: "Smart.Aggregation_Production",',
    '    AGGREGATION_IPE: "Smart.Aggregation_IPE",',
    '    ETAT_CAPTEUR: "Smart.EtatCapteur"'
  ];

  const entityDefinitions = allEntities.join('\n');

  const code = [
    '// This file was generated by Mendix Studio Pro.',
    '//',
    '// WARNING: Only the following code will be retained when actions are regenerated:',
    '// - the import list',
    '// - the code between BEGIN USER CODE and END USER CODE',
    '// - the code between BEGIN EXTRA CODE and END EXTRA CODE',
    '// Other code you write will be lost the next time you deploy the project.',
    'import "mx-global";',
    'import { Big } from "big.js";',
    '',
    '// BEGIN EXTRA CODE',
    'const ENTITIES = {',
    entityDefinitions,
    '};',
    '',
    '// Données des assets (structure hiérarchique complète)',
    'const ASSETS_DATA = ' + JSON.stringify(iihData, null, 2) + ';',
    '',
    '// Niveaux hiérarchiques',
    'const HIERARCHY_LEVELS = ' + JSON.stringify(hierarchyLevels, null, 2) + ';',
    '',
    '// Définition du mapping des entités Mendix',
    'const MENDIX_SUMMARY = ' + JSON.stringify(mendixSummary, null, 2) + ';',
    '// END EXTRA CODE',
    '',
    '/**',
    ' * @returns {Promise.<void>}',
    ' */',
    'export async function JavaScript_action() {',
    '    // BEGIN USER CODE',
    '    try {',
    '        // Vérification des données',
    '        console.log("[DEBUG] Checking data availability...");',
    '        if (!ASSETS_DATA) {',
    '            throw new Error("ASSETS_DATA is not defined");',
    '        }',
    '        console.log("[DEBUG] ASSETS_DATA is defined");',
    '        console.log("[DEBUG] ASSETS_DATA structure:", JSON.stringify(ASSETS_DATA, null, 2));',
    '',
    '        if (!MENDIX_SUMMARY) {',
    '            throw new Error("MENDIX_SUMMARY is not defined");',
    '        }',
    '        console.log("[DEBUG] MENDIX_SUMMARY is defined");',
    '        console.log("[DEBUG] MENDIX_SUMMARY structure:", JSON.stringify(MENDIX_SUMMARY, null, 2));',
    '',
    '        const createAndCommitObject = async (entity, attributes) => {',
    '            return new Promise((resolve, reject) => {',
    '                try {',
    '                    console.log("[CREATE] Starting entity creation: " + entity);',
    '                    console.log("[CREATE] Attributes: " + JSON.stringify(attributes));',
    '                    mx.data.create({',
    '                        entity: entity,',
    '                        callback: function(obj) {',
    '                            try {',
    '                                console.log("[CREATE] Entity created successfully");',
    '                                Object.entries(attributes).forEach(([key, value]) => {',
    '                                    if (value !== undefined && value !== null) {',
    '                                        console.log("[ATTRIBUTE] Setting " + key + " = " + value);',
    '                                        obj.set(key, value.toString());',
    '                                    }',
    '                                });',
    '                                console.log("[COMMIT] Attempting to commit");',
    '                                mx.data.commit({',
    '                                    mxobj: obj,',
    '                                    callback: function() {',
    '                                        console.log("[SUCCESS] Entity committed: " + entity);',
    '                                        resolve(obj);',
    '                                    },',
    '                                    error: function(e) {',
    '                                        console.error("[ERROR] Commit failed: " + e.message);',
    '                                        reject(new Error("Commit failed: " + e.message));',
    '                                    }',
    '                                });',
    '                            } catch (err) {',
    '                                console.error("[ERROR] Configuration failed: " + err.message);',
    '                                reject(new Error("Configuration failed: " + err.message));',
    '                            }',
    '                        },',
    '                        error: function(e) {',
    '                            console.error("[ERROR] Creation failed: " + e.message);',
    '                            reject(new Error("Creation failed: " + e.message));',
    '                        }',
    '                    });',
    '                } catch (err) {',
    '                    console.error("[ERROR] Global error: " + err.message);',
    '                    reject(err);',
    '                }',
    '            });',
    '        };',
    '',
    '        // Traitement direct des données hiérarchiques',
    '        const nodes = ASSETS_DATA.hierarchyData.nodes;',
    '        const links = ASSETS_DATA.hierarchyData.links;',
    '        console.log("[DEBUG] Processing nodes:", JSON.stringify(nodes, null, 2));',
    '        console.log("[DEBUG] Processing links:", JSON.stringify(links, null, 2));',
    '        console.log("[DEBUG] Hierarchy levels:", JSON.stringify(HIERARCHY_LEVELS, null, 2));',
    '',
    '        // Fonction pour trouver tous les parents d\'un noeud',
    '        const findAllParents = (nodeId) => {',
    '            const parents = [];',
    '            let currentNodeId = nodeId;',
    '',
    '            while (true) {',
    '                const parentLink = links.find(link => link.target === currentNodeId);',
    '                if (!parentLink) break;',
    '',
    '                const parentNode = nodes.find(node => node.id === parentLink.source);',
    '                if (!parentNode) break;',
    '',
    '                console.log("[DEBUG] Parent trouve pour " + nodeId + ":", {',
    '                    level: parentNode.metadata.level,',
    '                    name: parentNode.name',
    '                });',
    '',
    '                parents.push(parentNode);',
    '                currentNodeId = parentNode.id;',
    '            }',
    '',
    '            return parents;',
    '        };',
    '',
    '        // Creer les objets pour chaque niveau hierarchique',
    '        for (const level of HIERARCHY_LEVELS) {',
    '            const levelNodes = nodes.filter(node => node.metadata.level === level.name);',
    '            console.log("[DEBUG] Found " + level.name + ":", JSON.stringify(levelNodes, null, 2));',
    '',
    '            for (const node of levelNodes) {',
    '                console.log("[" + level.name.toUpperCase() + "] Creating " + level.name + ":", node.name);',
    '                const attributes = {',
    '                    "Nom": node.name,',
    '                    "TotalConso": "0"',
    '                };',
    '',
    '                // Pour tous les niveaux sauf le premier, chercher les parents',
    '                if (level.level > 0) {',
    '                    const parents = findAllParents(node.id);',
    '                    console.log("[DEBUG] Parents trouves pour " + node.name + ":", ',
    '                        parents.map(p => ({ level: p.metadata.level, name: p.name })));',
    '',
    '                    // Ajouter chaque parent comme attribut',
    '                    parents.forEach(parent => {',
    '                        const parentLevelName = parent.metadata.level;',
    '                        attributes[parentLevelName] = parent.name;',
    '                        console.log("[DEBUG] Ajout de attribut " + parentLevelName + "=" + parent.name);',
    '                    });',
    '                }',
    '',
    '                // Ajouter les attributs specifiques pour les machines',
    '                if (level.name === "Machine") {',
    '                    attributes["Identifiant"] = node.metadata.assetId || node.id;',
    '                    attributes["IPE"] = "0";',
    '                    attributes["TypeEnergie"] = node.metadata.energyType || node.metadata.rawEnergyType || "";',
    '',
    '                    // Trouver le secteur parent (directement ou via l\'atelier)',
    '                    const parentSecteur = findAllParents(node.id).find(p => p.metadata.level === "Secteur");',
    '                    if (parentSecteur) {',
    '                        console.log(`[DEBUG] Secteur parent trouve pour ${node.name}:`, parentSecteur.name);',
    '                        attributes["Secteur"] = parentSecteur.name;',
    '                    }',
    '',
    '                    // Trouver l\'atelier parent',
    '                    const parentAtelier = findAllParents(node.id).find(p => p.metadata.level === "Atelier");',
    '                    if (parentAtelier) {',
    '                        console.log(`[DEBUG] Atelier parent trouve pour ${node.name}:`, parentAtelier.name);',
    '                        attributes["Atelier"] = parentAtelier.name;',
    '                    }',
    '                }',
    '',
    '                // Creer l\'objet',
    '                await createAndCommitObject(',
    '                    ENTITIES[level.name.toUpperCase()],',
    '                    attributes',
    '                );',
    '',
    '                // Pour les machines, creer aussi les objets associes',
    '                if (level.name === "Machine") {',
    '                    // Traiter les variables de consommation',
    '                    if (node.metadata.variable) {',
    '                        console.log("[VARIABLE] Creating consumption variable for:", node.name);',
    '                        const aggConsoAttributes = {',
    '                            "VariableId": node.metadata.variable.id,',
    '                            "VariableName": node.metadata.variable.name,',
    '                            "AssetName": node.name,',
    '                            "Machine": node.name',
    '                        };',
    '',
    '                        if (node.metadata.variable.aggregations) {',
    '                            const aggs = node.metadata.variable.aggregations;',
    '                            if (aggs["5min"]) aggConsoAttributes["Identifiant5Min"] = aggs["5min"].id;',
    '                            if (aggs["1h"]) aggConsoAttributes["Identifiant1h"] = aggs["1h"].id;',
    '                            if (aggs["4h"]) aggConsoAttributes["Identifiant4h"] = aggs["4h"].id;',
    '                            if (aggs["8h"]) aggConsoAttributes["Identifiant8h"] = aggs["8h"].id;',
    '                            if (aggs["1d"]) aggConsoAttributes["Identifiant1day"] = aggs["1d"].id;',
    '                        }',
    '',
    '                        await createAndCommitObject("Smart.Aggregation_Conso", aggConsoAttributes);',
    '                    }',
    '',
    '                    // Traiter les variables de production',
    '                    if (node.metadata.productionVariable) {',
    '                        console.log("[VARIABLE] Creating production variable for:", node.name);',
    '                        const aggProdAttributes = {',
    '                            "VariableId": node.metadata.productionVariable.id,',
    '                            "VariableName": node.metadata.productionVariable.name,',
    '                            "AssetName": node.name,',
    '                            "Machine": node.name',
    '                        };',
    '',
    '                        if (node.metadata.productionVariable.aggregations) {',
    '                            const aggs = node.metadata.productionVariable.aggregations;',
    '                            if (aggs["5min"]) aggProdAttributes["Identifiant5Min"] = aggs["5min"].id;',
    '                            if (aggs["1h"]) aggProdAttributes["Identifiant1h"] = aggs["1h"].id;',
    '                            if (aggs["4h"]) aggProdAttributes["Identifiant4h"] = aggs["4h"].id;',
    '                            if (aggs["8h"]) aggProdAttributes["Identifiant8h"] = aggs["8h"].id;',
    '                            if (aggs["1d"]) aggProdAttributes["Identifiant1day"] = aggs["1d"].id;',
    '                        }',
    '',
    '                        await createAndCommitObject("Smart.Aggregation_Production", aggProdAttributes);',
    '                    }',
    '',
    '                    // Traiter les variables IPE',
    '                    if (node.metadata.ipeVariable) {',
    '                        console.log("[VARIABLE] Creating IPE variable for:", node.name);',
    '                        const aggIPEAttributes = {',
    '                            "VariableId": node.metadata.ipeVariable.id,',
    '                            "VariableName": node.metadata.ipeVariable.name,',
    '                            "AssetName": node.name,',
    '                            "Machine": node.name',
    '                        };',
    '',
    '                        if (node.metadata.ipeVariable.aggregations) {',
    '                            const aggs = node.metadata.ipeVariable.aggregations;',
    '                            if (aggs["5min"]) aggIPEAttributes["Identifiant5Min"] = aggs["5min"].id;',
    '                            if (aggs["1h"]) aggIPEAttributes["Identifiant1h"] = aggs["1h"].id;',
    '                            if (aggs["4h"]) aggIPEAttributes["Identifiant4h"] = aggs["4h"].id;',
    '                            if (aggs["8h"]) aggIPEAttributes["Identifiant8h"] = aggs["8h"].id;',
    '                            if (aggs["1d"]) aggIPEAttributes["Identifiant1day"] = aggs["1d"].id;',
    '                        }',
    '',
    '                        await createAndCommitObject("Smart.Aggregation_IPE", aggIPEAttributes);',
    '                    }',
    '',
    '                    // Traiter les etats des capteurs',
    '                    if (node.metadata.stateVariable) {',
    '                        console.log("[SENSOR] Creating sensor state for:", node.name);',
    '                        await createAndCommitObject(',
    '                            "Smart.EtatCapteur",',
    '                            {',
    '                                "NomCapteur": node.name,',
    '                                "Etat": "false",',
    '                                "DerniereMaj": new Date().toISOString(),',
    '                                "IdEtatCapteur": node.metadata.stateVariable.variableId',
    '                            }',
    '                        );',
    '                    }',
    '                }',
    '            }',
    '        }',
    '',
    '        mx.ui.info("Configuration terminée avec succès!", {});',
    '    } catch (error) {',
    '        console.error("Erreur lors de la configuration:", error);',
    '        mx.ui.error("Erreur lors de la configuration: " + error.message, {});',
    '        throw error;',
    '    }',
    '    // END USER CODE',
    '}'
  ].join('\n');

  return code;
}

export function generateDynamicCleanupCode(requiredEntities: RequiredEntity[], hierarchyLevels: HierarchyLevel[]): string {
  const allEntities = [
    ...hierarchyLevels.map(level => 
      `    ${level.name.toUpperCase()}: "Smart.${level.name}",`
    ),
    '    AGGREGATION_CONSO: "Smart.Aggregation_Conso",',
    '    AGGREGATION_PRODUCTION: "Smart.Aggregation_Production",',
    '    AGGREGATION_IPE: "Smart.Aggregation_IPE",',
    '    ETAT_CAPTEUR: "Smart.EtatCapteur"'
  ];

  const entityDefinitions = allEntities.join('\n');

  const code = [
    '// This file was generated by Mendix Studio Pro.',
    '//',
    '// WARNING: Only the following code will be retained when actions are regenerated:',
    '// - the import list',
    '// - the code between BEGIN USER CODE and END USER CODE',
    '// - the code between BEGIN EXTRA CODE and END EXTRA CODE',
    '// Other code you write will be lost the next time you deploy the project.',
    'import "mx-global";',
    'import { Big } from "big.js";',
    '',
    '// BEGIN EXTRA CODE',
    'const ENTITIES = {',
    entityDefinitions,
    '};',
    '',
    '// Niveaux hiérarchiques',
    'const HIERARCHY_LEVELS = ' + JSON.stringify(hierarchyLevels, null, 2) + ';',
    '// END EXTRA CODE',
    '',
    '/**',
    ' * @returns {Promise.<void>}',
    ' */',
    'export async function JavaScript_cleanup() {',
    '    // BEGIN USER CODE',
    '    try {',
    '        console.log("=== Début du nettoyage des entités ===");',
    '',
    '        function deleteAllEntitiesOfType(entityName) {',
    '            return new Promise((resolve, reject) => {',
    '                try {',
    '                    console.log(`Suppression des entités ${entityName}...`);',
    '                    mx.data.get({',
    '                        xpath: `//${entityName}`,',
    '                        callback: function(objs) {',
    '                            console.log(`${objs.length} ${entityName} trouvés`);',
    '                            const deletePromises = objs.map(obj => {',
    '                                return new Promise((resolveDelete) => {',
    '                                    mx.data.remove({',
    '                                        guid: obj.getGuid(),',
    '                                        callback: () => resolveDelete(true),',
    '                                        error: (e) => {',
    '                                            console.error(`Erreur lors de la suppression de ${entityName}:`, e);',
    '                                            resolveDelete(false);',
    '                                        }',
    '                                    });',
    '                                });',
    '                            });',
    '',
    '                            Promise.all(deletePromises)',
    '                                .then(() => {',
    '                                    console.log(`Suppression de ${entityName} terminée`);',
    '                                    resolve(true);',
    '                                })',
    '                                .catch(error => {',
    '                                    console.error(`Erreur lors de la suppression des ${entityName}:`, error);',
    '                                    reject(error);',
    '                                });',
    '                        },',
    '                        error: function(error) {',
    '                            console.error(`Erreur lors de la récupération des ${entityName}:`, error);',
    '                            reject(error);',
    '                        }',
    '                    });',
    '                } catch (err) {',
    '                    console.error(`Erreur globale pour ${entityName}:`, err);',
    '                    reject(err);',
    '                }',
    '            });',
    '        }',
    '',
    '        // Supprimer dans l\'ordre inverse de la création pour respecter les dépendances',
    '        const entitiesToDelete = [',
    '            ENTITIES.ETAT_CAPTEUR,',
    '            ENTITIES.AGGREGATION_IPE,',
    '            ENTITIES.AGGREGATION_PRODUCTION,',
    '            ENTITIES.AGGREGATION_CONSO,',
    '            ...HIERARCHY_LEVELS.map(level => ENTITIES[level.name.toUpperCase()]).reverse()',
    '        ];',
    '',
    '        async function processEntities() {',
    '            for (const entity of entitiesToDelete) {',
    '                try {',
    '                    await deleteAllEntitiesOfType(entity);',
    '                } catch (error) {',
    '                    console.error(`Erreur lors du nettoyage de ${entity}:`, error);',
    '                }',
    '            }',
    '        }',
    '',
    '        processEntities().then(() => {',
    '            console.log("=== Nettoyage terminé ===");',
    '            mx.ui.info("Nettoyage terminé avec succès!", {});',
    '        }).catch(error => {',
    '            console.error("Erreur lors du nettoyage:", error);',
    '            mx.ui.error("Erreur lors du nettoyage: " + error.message, {});',
    '        });',
    '    } catch (error) {',
    '        console.error("Erreur lors du nettoyage:", error);',
    '        mx.ui.error("Erreur lors du nettoyage: " + error.message, {});',
    '    }',
    '    // END USER CODE',
    '}'
  ].join('\n');

  return code;
} 